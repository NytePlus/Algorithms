---
---

工程规划：[https://www.luogu.com.cn/problem/P1260](https://www.luogu.com.cn/problem/P1260)

## 思考

对于$T_i - T_j \leq b$，建立$i$到$j$的有向边。从任意一个节点开启dfs获得一个dfs树。

如果将**后向边**单独拎出来，剩下的边做拓扑排序，可以容易求出不等式的解。

之后要考虑后向边，每次加入一个后向边$\langle u, v \rangle$，如果不等式不成立，则需要修改$v$的值并做一轮拓扑排序更新。

更新后：
- $u$值改变：这种情况是因为$v$是最短路树上$u$的祖先。$v$改变则$u$需要继续变，这种情况是无解
- $u$值不变，但之前考虑过的后向边变化

如果能够用一个方法给后向边排序，使得后考虑的后向边不会影响前一个的值...

## 差分约束

题目要求$T_i - T_j \leq b$，天然满足最短路数组$dis_v \leq dis_u + \langle u, v \rangle$，即如果从$j$向$i$建边求最短路，那么就会解出不等式。

最短路树上不等式取等。由于负边权存在$dis$可能为负，要保证最小值为0，需要将所有$dis$减去最小值。

对于图中的环，比如两个结点互相有一条指向对方的有向边，有不等式
$$
\begin{cases}
T_i - T_j \leq b_1 \\
T_j - T_i \leq b_2
\end{cases} \Rightarrow T_j - b_2 \leq T_i \leq T_j + b_1
$$

如果出现负环，则$T_i$的下界大于上界，不等式不成立

## 负边权最短路

SPFA相较于Bellman-ford算法：后者每轮循环要检查所有边，前者只检查这样的边——它的起点在上一轮$dis$有更新。

有负环的情况下，Bellman-ford算法n轮之后考虑到了长度为n的路径，它的长度可能大于长度为n+1的路径。

所以有负环的情况下，Bellman-ford第n+1轮依然可以更新答案，SPFA一个结点入队n+1次。用这个方法判断负环